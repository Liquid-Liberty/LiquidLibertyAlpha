# ğŸ—ï¸ Serverless API Architecture

## System Overview

The Liquid Liberty Serverless API provides backend services through Netlify Edge Functions. These functions handle operations that require server-side execution, including cryptographic operations, IPFS uploads, and secure data proxying.

## Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FRONTEND APPLICATION                      â”‚
â”‚  - React DApp                                               â”‚
â”‚  - User interactions                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼ (HTTPS Requests)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  NETLIFY EDGE NETWORK                        â”‚
â”‚  - Global CDN                                               â”‚
â”‚  - DDoS Protection                                          â”‚
â”‚  - Request Routing                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              SERVERLESS FUNCTIONS LAYER                      â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         Image Upload Function                         â”‚  â”‚
â”‚  â”‚  POST /upload-images-to-ipfs                         â”‚  â”‚
â”‚  â”‚                                                       â”‚  â”‚
â”‚  â”‚  1. Validate images                                   â”‚  â”‚
â”‚  â”‚  2. Convert base64 â†’ Buffer                          â”‚  â”‚
â”‚  â”‚  3. Upload to Pinata IPFS                            â”‚  â”‚
â”‚  â”‚  4. Create metadata JSON                             â”‚  â”‚
â”‚  â”‚  5. Upload metadata to IPFS                          â”‚  â”‚
â”‚  â”‚  6. Return IPFS hashes                               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚      Signature Generation Function                    â”‚  â”‚
â”‚  â”‚  POST /create-listing-signature                      â”‚  â”‚
â”‚  â”‚                                                       â”‚  â”‚
â”‚  â”‚  1. Validate listing parameters                       â”‚  â”‚
â”‚  â”‚  2. Load trusted signer wallet                       â”‚  â”‚
â”‚  â”‚  3. Create EIP-712 typed data                        â”‚  â”‚
â”‚  â”‚  4. Sign with private key                            â”‚  â”‚
â”‚  â”‚  5. Return signature (v, r, s)                       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚       Content Moderation Function                     â”‚  â”‚
â”‚  â”‚  POST /moderate                                       â”‚  â”‚
â”‚  â”‚                                                       â”‚  â”‚
â”‚  â”‚  1. Check banned words                                â”‚  â”‚
â”‚  â”‚  2. Profanity detection                              â”‚  â”‚
â”‚  â”‚  3. Content appropriateness                          â”‚  â”‚
â”‚  â”‚  4. Return approval/rejection                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚       Secure Proxy Function                          â”‚  â”‚
â”‚  â”‚  POST /secure-subquery-proxy                         â”‚  â”‚
â”‚  â”‚                                                       â”‚  â”‚
â”‚  â”‚  1. Validate request                                 â”‚  â”‚
â”‚  â”‚  2. Proxy to indexer GraphQL                         â”‚  â”‚
â”‚  â”‚  3. Transform response                               â”‚  â”‚
â”‚  â”‚  4. Return data                                      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚       Vendor Simulation Function                      â”‚  â”‚
â”‚  â”‚  POST /submit-vendor-simulation                      â”‚  â”‚
â”‚  â”‚                                                       â”‚  â”‚
â”‚  â”‚  1. Validate vendor data                             â”‚  â”‚
â”‚  â”‚  2. Upload to IPFS                                   â”‚  â”‚
â”‚  â”‚  3. Return IPFS reference                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                               â”‚
       â–¼                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Pinata IPFS    â”‚          â”‚  Blockchain Indexer  â”‚
â”‚  - Image storageâ”‚          â”‚  - GraphQL API       â”‚
â”‚  - Metadata     â”‚          â”‚  - Chart data        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Function Flow Diagrams

### 1. Image Upload Flow

```
User submits listing with images
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Frontend prepares request            â”‚
â”‚                                      â”‚
â”‚ 1. Read image files                  â”‚
â”‚ 2. Convert to base64                 â”‚
â”‚ 3. Prepare listing metadata          â”‚
â”‚ 4. Bundle into JSON payload          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼ (POST)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Netlify Edge receives request        â”‚
â”‚ Route: /.netlify/functions/          â”‚
â”‚        upload-images-to-ipfs         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Function: upload-images-to-ipfs.js   â”‚
â”‚                                      â”‚
â”‚ Step 1: Validate request             â”‚
â”‚ âœ“ Check images array exists          â”‚
â”‚ âœ“ Check listingData exists           â”‚
â”‚ âœ“ Validate image formats             â”‚
â”‚ âœ“ Check file sizes (<10MB)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 2: Process each image           â”‚
â”‚                                      â”‚
â”‚ for (image of images) {              â”‚
â”‚   // Extract base64 data             â”‚
â”‚   const base64Data = image.data      â”‚
â”‚     .replace(/^data:image\/\w+;      â”‚
â”‚              base64,/, '');          â”‚
â”‚                                      â”‚
â”‚   // Convert to Buffer               â”‚
â”‚   const buffer = Buffer.from(        â”‚
â”‚     base64Data,                      â”‚
â”‚     'base64'                         â”‚
â”‚   );                                 â”‚
â”‚                                      â”‚
â”‚   // Create readable stream          â”‚
â”‚   const stream = Readable.from(      â”‚
â”‚     buffer                           â”‚
â”‚   );                                 â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 3: Upload images to Pinata      â”‚
â”‚                                      â”‚
â”‚ const result = await pinata          â”‚
â”‚   .pinFileToIPFS(stream, {           â”‚
â”‚     pinataMetadata: {                â”‚
â”‚       name: image.name               â”‚
â”‚     }                                â”‚
â”‚   });                                â”‚
â”‚                                      â”‚
â”‚ Store result:                        â”‚
â”‚ {                                    â”‚
â”‚   IpfsHash: "QmXXX...",              â”‚
â”‚   PinSize: 123456,                   â”‚
â”‚   Timestamp: "2024-01-01..."         â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 4: Collect image references     â”‚
â”‚                                      â”‚
â”‚ imageReferences = [                  â”‚
â”‚   {                                  â”‚
â”‚     originalName: "photo1.jpg",      â”‚
â”‚     ipfsHash: "QmXXX...",            â”‚
â”‚     ipfsUrl: "ipfs://QmXXX...",      â”‚
â”‚     gatewayUrl: "https://           â”‚
â”‚       gateway.pinata.cloud/          â”‚
â”‚       ipfs/QmXXX...",                â”‚
â”‚     size: 123456                     â”‚
â”‚   },                                 â”‚
â”‚   ...                                â”‚
â”‚ ]                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 5: Create metadata JSON         â”‚
â”‚                                      â”‚
â”‚ metadata = {                         â”‚
â”‚   title: listingData.title,          â”‚
â”‚   description: listingData.desc,     â”‚
â”‚   category: listingData.category,    â”‚
â”‚   price: listingData.price,          â”‚
â”‚   images: imageReferences,           â”‚
â”‚   createdAt: Date.now(),             â”‚
â”‚   userAddress: listingData.user      â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 6: Upload metadata to Pinata    â”‚
â”‚                                      â”‚
â”‚ const metadataResult = await pinata  â”‚
â”‚   .pinJSONToIPFS(metadata, {         â”‚
â”‚     pinataMetadata: {                â”‚
â”‚       name: `listing-${user}-        â”‚
â”‚              ${timestamp}.json`      â”‚
â”‚     }                                â”‚
â”‚   });                                â”‚
â”‚                                      â”‚
â”‚ metadataHash = metadataResult        â”‚
â”‚   .IpfsHash                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 7: Return response              â”‚
â”‚                                      â”‚
â”‚ {                                    â”‚
â”‚   success: true,                     â”‚
â”‚   listingMetadataHash: "QmZZZ...",   â”‚
â”‚   listingMetadataUrl:                â”‚
â”‚     "ipfs://QmZZZ...",               â”‚
â”‚   images: imageReferences            â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        Frontend receives response
      Uses IPFS hash for listing
```

### 2. EIP-712 Signature Generation Flow

```
User requests to create listing
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Frontend prepares signature request  â”‚
â”‚                                      â”‚
â”‚ {                                    â”‚
â”‚   listingType: 0,  // item           â”‚
â”‚   dataIdentifier: "ipfs://QmXXX",    â”‚
â”‚   userAddress: "0x123...",           â”‚
â”‚   feeInToken: "10000000000000000000",â”‚
â”‚   deadline: timestamp + 3600         â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼ (POST)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Netlify Edge receives request        â”‚
â”‚ Route: /.netlify/functions/          â”‚
â”‚        create-listing-signature      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Function: create-listing-            â”‚
â”‚           signature.js               â”‚
â”‚                                      â”‚
â”‚ Step 1: Validate inputs              â”‚
â”‚ âœ“ listingType is number (0-255)     â”‚
â”‚ âœ“ dataIdentifier is string           â”‚
â”‚ âœ“ userAddress is valid Ethereum addr â”‚
â”‚ âœ“ feeInToken is valid uint256        â”‚
â”‚ âœ“ deadline is future timestamp       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 2: Load trusted signer          â”‚
â”‚                                      â”‚
â”‚ const provider = new ethers          â”‚
â”‚   .JsonRpcProvider(                  â”‚
â”‚     process.env.JSON_RPC_URL         â”‚
â”‚   );                                 â”‚
â”‚                                      â”‚
â”‚ const signer = new ethers.Wallet(    â”‚
â”‚   process.env.SIGNER_PRIVATE_KEY,    â”‚
â”‚   provider                           â”‚
â”‚ );                                   â”‚
â”‚                                      â”‚
â”‚ const network = await provider       â”‚
â”‚   .getNetwork();                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 3: Create EIP-712 domain        â”‚
â”‚                                      â”‚
â”‚ const domain = {                     â”‚
â”‚   name: "ListingManager",            â”‚
â”‚   version: "1",                      â”‚
â”‚   chainId: network.chainId,          â”‚
â”‚   verifyingContract:                 â”‚
â”‚     process.env.LISTING_MANAGER_     â”‚
â”‚     ADDRESS                          â”‚
â”‚ };                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 4: Define types                 â”‚
â”‚                                      â”‚
â”‚ const types = {                      â”‚
â”‚   CreateListing: [                   â”‚
â”‚     {                                â”‚
â”‚       name: "listingType",           â”‚
â”‚       type: "uint8"                  â”‚
â”‚     },                               â”‚
â”‚     {                                â”‚
â”‚       name: "dataIdentifier",        â”‚
â”‚       type: "string"                 â”‚
â”‚     },                               â”‚
â”‚     {                                â”‚
â”‚       name: "user",                  â”‚
â”‚       type: "address"                â”‚
â”‚     },                               â”‚
â”‚     {                                â”‚
â”‚       name: "feeInToken",            â”‚
â”‚       type: "uint256"                â”‚
â”‚     },                               â”‚
â”‚     {                                â”‚
â”‚       name: "deadline",              â”‚
â”‚       type: "uint256"                â”‚
â”‚     }                                â”‚
â”‚   ]                                  â”‚
â”‚ };                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 5: Create message               â”‚
â”‚                                      â”‚
â”‚ const message = {                    â”‚
â”‚   listingType: listingType,          â”‚
â”‚   dataIdentifier: dataIdentifier,    â”‚
â”‚   user: userAddress,                 â”‚
â”‚   feeInToken: feeInToken,            â”‚
â”‚   deadline: deadline                 â”‚
â”‚ };                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 6: Sign typed data              â”‚
â”‚                                      â”‚
â”‚ const signature = await signer       â”‚
â”‚   ._signTypedData(                   â”‚
â”‚     domain,                          â”‚
â”‚     types,                           â”‚
â”‚     message                          â”‚
â”‚   );                                 â”‚
â”‚                                      â”‚
â”‚ // Signature is 65 bytes:            â”‚
â”‚ // r (32) + s (32) + v (1)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 7: Split signature              â”‚
â”‚                                      â”‚
â”‚ const sig = ethers.Signature         â”‚
â”‚   .from(signature);                  â”‚
â”‚                                      â”‚
â”‚ const signatureComponents = {        â”‚
â”‚   v: sig.v,                          â”‚
â”‚   r: sig.r,                          â”‚
â”‚   s: sig.s                           â”‚
â”‚ };                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 8: Return signature             â”‚
â”‚                                      â”‚
â”‚ {                                    â”‚
â”‚   success: true,                     â”‚
â”‚   signature: {                       â”‚
â”‚     v: 27,                           â”‚
â”‚     r: "0x1234...",                  â”‚
â”‚     s: "0x5678..."                   â”‚
â”‚   },                                 â”‚
â”‚   signer: "0xABC...",                â”‚
â”‚   message: "Signature generated"     â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        Frontend receives signature
     Uses it to call contract
```

### 3. Content Moderation Flow

```
User submits listing content
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Frontend sends content for validationâ”‚
â”‚                                      â”‚
â”‚ {                                    â”‚
â”‚   title: "Listing Title",            â”‚
â”‚   description: "Full description...", â”‚
â”‚   category: "electronics"            â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼ (POST)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Function: moderate.js                â”‚
â”‚                                      â”‚
â”‚ Step 1: Load banned words list       â”‚
â”‚ const bannedWords = require(         â”‚
â”‚   './banned-words.json'              â”‚
â”‚ );                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 2: Check banned words           â”‚
â”‚                                      â”‚
â”‚ const content = (                    â”‚
â”‚   title + ' ' + description          â”‚
â”‚ ).toLowerCase();                     â”‚
â”‚                                      â”‚
â”‚ const foundBannedWords = [];         â”‚
â”‚                                      â”‚
â”‚ for (const word of bannedWords) {    â”‚
â”‚   if (content.includes(              â”‚
â”‚     word.toLowerCase()               â”‚
â”‚   )) {                               â”‚
â”‚     foundBannedWords.push(word);     â”‚
â”‚   }                                  â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 3: Profanity detection          â”‚
â”‚                                      â”‚
â”‚ const { isProfane } =                â”‚
â”‚   require('content-checker');        â”‚
â”‚                                      â”‚
â”‚ const hasProfanity = isProfane(      â”‚
â”‚   content                            â”‚
â”‚ );                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 4: Category-specific rules      â”‚
â”‚                                      â”‚
â”‚ const rules = {                      â”‚
â”‚   electronics: {                     â”‚
â”‚     requiredWords: ['condition'],    â”‚
â”‚     minLength: 50                    â”‚
â”‚   },                                 â”‚
â”‚   services: {                        â”‚
â”‚     requiredWords: ['available'],    â”‚
â”‚     minLength: 100                   â”‚
â”‚   }                                  â”‚
â”‚ };                                   â”‚
â”‚                                      â”‚
â”‚ const categoryRule = rules[category];â”‚
â”‚ if (categoryRule) {                  â”‚
â”‚   // Apply category rules            â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 5: Build response               â”‚
â”‚                                      â”‚
â”‚ const issues = [];                   â”‚
â”‚                                      â”‚
â”‚ if (foundBannedWords.length > 0) {   â”‚
â”‚   issues.push(                       â”‚
â”‚     `Contains banned words: ${       â”‚
â”‚       foundBannedWords.join(', ')    â”‚
â”‚     }`                               â”‚
â”‚   );                                 â”‚
â”‚ }                                    â”‚
â”‚                                      â”‚
â”‚ if (hasProfanity) {                  â”‚
â”‚   issues.push(                       â”‚
â”‚     "Inappropriate content detected" â”‚
â”‚   );                                 â”‚
â”‚ }                                    â”‚
â”‚                                      â”‚
â”‚ return {                             â”‚
â”‚   approved: issues.length === 0,     â”‚
â”‚   issues: issues                     â”‚
â”‚ };                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        Frontend receives result
     Allows/blocks submission
```

## Security Architecture

### 1. Private Key Management

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Netlify Environment Variables        â”‚
â”‚ (Encrypted at rest)                  â”‚
â”‚                                      â”‚
â”‚ SIGNER_PRIVATE_KEY=0x...             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ (Loaded at runtime)
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Function Execution Context           â”‚
â”‚ (Ephemeral, destroyed after use)     â”‚
â”‚                                      â”‚
â”‚ const key = process.env              â”‚
â”‚   .SIGNER_PRIVATE_KEY                â”‚
â”‚                                      â”‚
â”‚ const signer = new Wallet(key)       â”‚
â”‚                                      â”‚
â”‚ // Use for signing                   â”‚
â”‚                                      â”‚
â”‚ // Key never exposed to client       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. CORS Protection

```
Request from https://attacker.com
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Netlify Edge Function                â”‚
â”‚                                      â”‚
â”‚ const origin = event.headers.origin; â”‚
â”‚                                      â”‚
â”‚ const allowedOrigins = [             â”‚
â”‚   'https://yourapp.netlify.app',     â”‚
â”‚   'http://localhost:5173'            â”‚
â”‚ ];                                   â”‚
â”‚                                      â”‚
â”‚ if (!allowedOrigins.includes(        â”‚
â”‚   origin                             â”‚
â”‚ )) {                                 â”‚
â”‚   return {                           â”‚
â”‚     statusCode: 403,                 â”‚
â”‚     body: 'Forbidden'                â”‚
â”‚   };                                 â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. Input Sanitization

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Validate Ethereum Address            â”‚
â”‚                                      â”‚
â”‚ function isValidAddress(addr) {      â”‚
â”‚   return /^0x[a-fA-F0-9]{40}$/       â”‚
â”‚     .test(addr);                     â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Validate Amount                      â”‚
â”‚                                      â”‚
â”‚ function isValidAmount(amount) {     â”‚
â”‚   try {                              â”‚
â”‚     const bn = BigInt(amount);       â”‚
â”‚     return bn > 0n;                  â”‚
â”‚   } catch {                          â”‚
â”‚     return false;                    â”‚
â”‚   }                                  â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sanitize Strings                     â”‚
â”‚                                      â”‚
â”‚ function sanitize(str) {             â”‚
â”‚   return str                         â”‚
â”‚     .replace(/<script>/gi, '')       â”‚
â”‚     .replace(/javascript:/gi, '')    â”‚
â”‚     .trim()                          â”‚
â”‚     .slice(0, 1000); // Max length   â”‚
â”‚ }                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Error Handling

### Standard Error Response

```javascript
try {
  // Function logic
} catch (error) {
  console.error('Function error:', error);

  return {
    statusCode: 500,
    headers: corsHeaders,
    body: JSON.stringify({
      success: false,
      error: error.message,
      code: error.code || 'INTERNAL_ERROR'
    })
  };
}
```

### Error Codes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Code       â”‚ Description                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 400        â”‚ Bad Request - Invalid input      â”‚
â”‚ 401        â”‚ Unauthorized - Missing auth      â”‚
â”‚ 403        â”‚ Forbidden - CORS violation       â”‚
â”‚ 404        â”‚ Not Found - Invalid endpoint     â”‚
â”‚ 413        â”‚ Payload Too Large - >10MB        â”‚
â”‚ 429        â”‚ Too Many Requests - Rate limited â”‚
â”‚ 500        â”‚ Internal Server Error            â”‚
â”‚ 502        â”‚ Bad Gateway - External API fail  â”‚
â”‚ 503        â”‚ Service Unavailable - IPFS down  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Performance Optimizations

### 1. Parallel Uploads

```javascript
// Upload images in parallel
const uploadPromises = images.map(image =>
  uploadToPinata(image)
);

const results = await Promise.all(uploadPromises);
```

### 2. Response Caching

```javascript
const headers = {
  'Cache-Control': 'public, max-age=3600',
  'ETag': generateETag(data)
};
```

### 3. Compression

```javascript
const zlib = require('zlib');

const compressed = zlib.gzipSync(
  JSON.stringify(data)
);

return {
  statusCode: 200,
  headers: {
    'Content-Encoding': 'gzip'
  },
  body: compressed
};
```

## Integration Points

### Smart Contracts
- Generates signatures for ListingManager
- Validates contract addresses
- Checks network compatibility

### Blockchain Indexer
- Proxies GraphQL queries
- Caches chart data
- Transforms responses

### Frontend DApp
- Receives API calls
- Returns IPFS hashes
- Provides signatures

### External Services
- Pinata IPFS
- Ethereum RPC providers
- Content moderation APIs
